<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiktoken 分词可视化器</title>
    <style>
        .token {
            display: inline-block;
            padding: 4px 8px;
            margin: 2px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f0f0f0;
            font-family: monospace;
        }
        .token:hover {
            background-color: #e0e0e0;
        }
        .token.partial {
            background-color: #ffe0e0;
            color: #666;
        }
        .token.space {
            background-color: #e0f0ff;
        }
        .token.merged {
            background-color: #fff0e0;
            border-color: #ff9900;
        }
        #container {
            padding: 20px;
        }
        #info {
            margin: 20px 0;
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="container">
        <h2>Tiktoken 分词可视化</h2>
        <div id="info"></div>
        <div id="tokens-display"></div>
    </div>
    <script type="module">
        import { getEncoding } from "https://esm.sh/js-tiktoken";

        const encoding = getEncoding("cl100k_base");
        const sentence = `Hello World! 这里的每一个色块代表一个独立的 Token。`;
        const tokens = encoding.encode(sentence);
        
        console.log('原始文本:', sentence);
        console.log('Token IDs:', tokens);
        
        // 显示信息
        const info = document.getElementById('info');
        info.innerHTML = `
            <strong>原始文本:</strong> ${sentence}<br>
            <strong>Token 数量:</strong> ${tokens.length}<br>
            <strong>重建文本:</strong> ${encoding.decode(tokens)}
        `;
        
        // 改进的解析方法：处理部分字节的组合
        const display = document.getElementById('tokens-display');
        const processedTokens = [];
        let i = 0;
        
        while (i < tokens.length) {
            // 尝试单独解码当前 token
            let tokenText = '';
            let tokenIds = [tokens[i]];
            let isMerged = false;
            
            try {
                tokenText = encoding.decode([tokens[i]]);
            } catch (e) {
                // 单独解码失败，尝试与后续 token 组合
                isMerged = true;
                let j = i + 1;
                
                // 继续添加 token 直到能成功解码
                while (j < tokens.length) {
                    tokenIds.push(tokens[j]);
                    try {
                        tokenText = encoding.decode(tokenIds);
                        // 成功解码，跳出循环
                        break;
                    } catch (e) {
                        // 继续添加下一个 token
                        j++;
                    }
                }
                
                // 如果到达末尾仍无法解码，使用累积方法
                if (tokenText === '') {
                    const beforeText = i > 0 ? encoding.decode(tokens.slice(0, i)) : '';
                    const afterText = encoding.decode(tokens.slice(0, j + 1));
                    tokenText = afterText.substring(beforeText.length);
                }
            }
            
            // 使用累积方法验证
            const beforeText = i > 0 ? encoding.decode(tokens.slice(0, i)) : '';
            const afterText = encoding.decode(tokens.slice(0, i + tokenIds.length));
            const actualText = afterText.substring(beforeText.length);
            
            // 如果累积方法得到的文本不同，使用累积方法的结果
            if (actualText && actualText !== tokenText) {
                tokenText = actualText;
            }
            
            processedTokens.push({
                ids: tokenIds,
                text: tokenText,
                isMerged: isMerged,
                startIndex: i,
                endIndex: i + tokenIds.length - 1
            });
            
            // 创建显示元素
            const span = document.createElement('span');
            span.className = 'token';
            
            let displayText = tokenText;
            
            // 处理特殊字符显示
            if (tokenText === '') {
                displayText = `∅`;
                span.className += ' partial';
            } else if (tokenText === ' ') {
                displayText = '␣';
                span.className += ' space';
            } else if (tokenText === '\n') {
                displayText = '↵';
            } else if (tokenText === '\t') {
                displayText = '⇥';
            }
            
            if (isMerged) {
                span.className += ' merged';
            }
            
            span.textContent = displayText;
            span.title = `Tokens #${i}${isMerged ? `-${i + tokenIds.length - 1}` : ''}\nIDs: [${tokenIds.join(', ')}]\n内容: "${tokenText}"${isMerged ? '\n(合并的 tokens)' : ''}`;
            
            // 如果是合并的 tokens，添加标记
            if (isMerged || tokenText === '') {
                const sub = document.createElement('sub');
                sub.textContent = `[${tokenIds.join(',')}]`;
                sub.style.fontSize = '10px';
                sub.style.color = '#666';
                span.appendChild(sub);
            }
            
            display.appendChild(span);
            
            console.log(`Token ${i}${isMerged ? `-${i + tokenIds.length - 1}` : ''}: IDs=[${tokenIds.join(', ')}], Text="${tokenText}", Merged=${isMerged}`);
            
            i += tokenIds.length;
        }
        
        // 验证解码
        const reconstructed = encoding.decode(tokens);
        console.log('重建文本是否匹配:', reconstructed === sentence);
        console.log('处理后的 tokens:', processedTokens);
    </script>
</body>
</html>