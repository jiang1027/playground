// ==UserScript==
// @name        XMaster: Power Tools for X (Twitter)
// @name:ar     إكس ماستر: أدوات قوية لمنصة X (تويتر)
// @name:bg     XMaster: Мощни инструменти за X (Twitter)
// @name:ckb    XMaster: ئامرازە بەهێزەکان بۆ X (Twitter)
// @name:cs     XMaster: Výkonné nástroje pro X (Twitter)
// @name:da     XMaster: Avancerede værktøjer til X (Twitter)
// @name:de     XMaster: Leistungsstarke Tools für X (Twitter)
// @name:el     XMaster: Ισχυρά εργαλεία για το X (Twitter)
// @name:en     XMaster: Power Tools for X (Twitter)
// @name:eo     XMaster: Potencaj iloj por X (Twitter)
// @name:es     XMaster: Herramientas avanzadas para X (Twitter)
// @name:es-419 XMaster: Herramientas avanzadas para X (Twitter)
// @name:fi     XMaster: Tehokkaat työkalut X:lle (Twitter)
// @name:fr     XMaster : Outils puissants pour X (Twitter)
// @name:fr-CA  XMaster : Outils puissants pour X (Twitter)
// @name:he     XMaster: כלים מתקדמים ל-X (טוויטר)
// @name:hr     XMaster: Napredni alati za X (Twitter)
// @name:hu     XMaster: Hatékony eszközök az X (Twitter) számára
// @name:id     XMaster: Alat Canggih untuk X (Twitter)
// @name:it     XMaster: Strumenti avanzati per X (Twitter)
// @name:ja     XMaster：X（Twitter）の強力ツール
// @name:ka     XMaster: მძლავრი ხელსაწყოები X-ისთვის (Twitter)
// @name:ko     XMaster: X (Twitter)을 위한 고급 도구
// @name:nb     XMaster: Kraftige verktøy for X (Twitter)
// @name:nl     XMaster: Krachtige tools voor X (Twitter)
// @name:pl     XMaster: Zaawansowane narzędzia dla X (Twitter)
// @name:pt-BR  XMaster: Ferramentas avançadas para X (Twitter)
// @name:ro     XMaster: Instrumente avansate pentru X (Twitter)
// @name:ru     XMaster: Мощные инструменты для X (Twitter)
// @name:sk     XMaster: Výkonné nástroje pre X (Twitter)
// @name:sr     XMaster: Napredni alati za X (Twitter)
// @name:sv     XMaster: Kraftfulla verktyg för X (Twitter)
// @name:th     XMaster: เครื่องมือทรงพลังสำหรับ X (Twitter)
// @name:tr     XMaster: X (Twitter) için Güçlü Araçlar
// @name:uk     XMaster: Потужні інструменти для X (Twitter)
// @name:ug     XMaster: X (Twitter) ئۈچۈن كۈچلۈك قوراللار
// @name:vi     XMaster: Công cụ mạnh mẽ cho X (Twitter)
// @description        The script enhances Twitter (X) and TikTok by improving features such as date format, image and video downloads, and more for Twitter (X), and video downloads for TikTok. It will be continuously maintained and updated, so you can use it with confidence.
// @description:ar     يعمل السكربت على تحسين تويتر (X) وتيك توك عن طريق تحسين ميزات مثل تنسيق التاريخ، تحميل الصور والفيديوهات، والمزيد لتويتر (X)، وتحميل الفيديوهات لتيك توك. سيتم صيانته وتحديثه باستمرار، حتى تتمكن من استخدامه بثقة.
// @description:bg     Скриптът подобрява Twitter (X) и TikTok чрез подобряване на функции като формат на дата, изтегляне на изображения и видеоклипове и други за Twitter (X) и изтегляне на видеоклипове за TikTok. Той ще се поддържа и обновява непрекъснато, така че можете да го използвате с увереност.
// @description:ckb    اسکریپتەکە تەنها تایبەتمەندیەکانەی تیوتر (X) و تیکتۆکەکان پەسەند دەکات وەکوو فۆرماتی ڕووداو، داگرتنی وێنە و ڤیدیۆ و زۆرتر بۆ تیوتر (X) و داگرتنی ڤیدیۆ بۆ تیکتۆک. ئەم پڕۆگرامە بە شێوەیەکی پەیوەندیدار و نوێ دەبێت، بۆیە دەتوانیت بە بەرەوپێش کارەکە بە بەرەوپێش بەکاربەریت.
// @description:cs     Skript zlepšuje Twitter (X) a TikTok vylepšením funkcí jako je formát data, stahování obrázků a videí a další pro Twitter (X), a stahování videí pro TikTok. Bude neustále udržováno a aktualizováno, takže ho můžete používat s důvěrou.
// @description:da     Scriptet forbedrer Twitter (X) og TikTok ved at forbedre funktioner som datoformat, billede- og video-downloads og mere for Twitter (X), samt video-downloads for TikTok. Det vil løbende blive vedligeholdt og opdateret, så du kan bruge det med tillid.
// @description:de     Das Skript verbessert Twitter (X) und TikTok, indem es Funktionen wie das Datumsformat, das Herunterladen von Bildern und Videos und mehr für Twitter (X) sowie das Herunterladen von Videos für TikTok verbessert. Es wird kontinuierlich gewartet und aktualisiert, damit Sie es mit Vertrauen verwenden können.
// @description:el     Το σενάριο βελτιώνει το Twitter (X) και το TikTok, βελτιώνοντας δυνατότητες όπως η μορφή ημερομηνίας, η λήψη εικόνας και βίντεο και άλλα για το Twitter (X) και η λήψη βίντεο για το TikTok. Θα συντηρείται και θα ενημερώνεται συνεχώς, ώστε να το χρησιμοποιείτε με εμπιστοσύνη.
// @description:en     The script enhances Twitter (X) and TikTok by improving features such as date format, image and video downloads, and more for Twitter (X), and video downloads for TikTok. It will be continuously maintained and updated, so you can use it with confidence.
// @description:eo     La skripto plibonigas Twitter (X) kaj TikTok per plibonigo de funkcioj kiel dato-formato, bildaj kaj videodownloads, kaj pli por Twitter (X), kaj videodownloads por TikTok. Ĝi estos konstante subtenata kaj ĝisdatigita, tiel ke vi povas uzi ĝin kun konfido.
// @description:es     El script mejora Twitter (X) y TikTok al mejorar características como el formato de fecha, descargas de imágenes y videos, y más para Twitter (X), y descargas de videos para TikTok. Será mantenido y actualizado de manera continua, por lo que puedes usarlo con confianza.
// @description:es-419 El script mejora Twitter (X) y TikTok mejorando características como el formato de fecha, descargas de imágenes y videos, y más para Twitter (X), y descargas de videos para TikTok. Se mantendrá y actualizará continuamente, por lo que puedes usarlo con confianza.
// @description:fi     Skripti parantaa Twitter (X):ää ja TikTokia parantamalla ominaisuuksia, kuten päivämäärämuotoa, kuvien ja videoiden latauksia ja enemmän Twitter (X):lle sekä videoiden latausta TikTokille. Sitä ylläpidetään ja päivitetään jatkuvasti, joten voit käyttää sitä luottavaisin mielin.
// @description:fr     Le script améliore Twitter (X) et TikTok en améliorant des fonctionnalités telles que le format de la date, le téléchargement d'images et de vidéos, et plus encore pour Twitter (X), et le téléchargement de vidéos pour TikTok. Il sera continuellement maintenu et mis à jour, vous pouvez donc l'utiliser en toute confiance.
// @description:fr-CA  Le script améliore Twitter (X) et TikTok en améliorant des fonctionnalités telles que le format de la date, les téléchargements d'images et de vidéos, et plus encore pour Twitter (X), ainsi que les téléchargements de vidéos pour TikTok. Il sera maintenu et mis à jour en continu, afin que vous puissiez l'utiliser en toute confiance.
// @description:he     הסקריפט משדרג את טוויטר (X) ואת טיקטוק על ידי שיפור תכונות כמו פורמט תאריך, הורדת תמונות ווידאו, ועוד עבור טוויטר (X), והורדות וידאו עבור טיקטוק. הוא יתוחזק ויתעדכן באופן רציף, כך שתוכל להשתמש בו בביטחון.
// @description:hr     Skript poboljšava Twitter (X) i TikTok poboljšanjem funkcija kao što su format datuma, preuzimanje slika i videa i drugo za Twitter (X) te preuzimanje videa za TikTok. Bit će kontinuirano održavan i ažuriran, tako da ga možete koristiti s povjerenjem.
// @description:hu     A script javítja a Twitter (X) és TikTok szolgáltatásokat olyan funkciók javításával, mint a dátumformátum, képek és videók letöltése, és még sok más a Twitter (X) számára, valamint videók letöltése a TikTok számára. Folyamatosan karbantartva és frissítve lesz, így bizalommal használhatod.
// @description:id     Skrip ini meningkatkan Twitter (X) dan TikTok dengan memperbaiki fitur seperti format tanggal, unduhan gambar dan video, dan lebih banyak lagi untuk Twitter (X), serta unduhan video untuk TikTok. Skrip ini akan terus dipelihara dan diperbarui, sehingga Anda dapat menggunakannya dengan percaya diri.
// @description:it     Lo script migliora Twitter (X) e TikTok migliorando funzionalità come il formato della data, il download di immagini e video e altro per Twitter (X), e il download di video per TikTok. Sarà continuamente mantenuto e aggiornato, quindi puoi usarlo con fiducia.
// @description:ja     このスクリプトは、Twitter (X) と TikTok の機能を改善し、Twitter (X) では日付形式、画像や動画のダウンロード、その他の機能を改善し、TikTok では動画のダウンロード機能を向上させます。継続的にメンテナンスされ、更新されるため、安心して使用できます。
// @description:ka     სკრიპტი აუმჯობესებს Twitter (X) და TikTok-ს, აძლიერებს ისეთ მახასიათებლებს, როგორიცაა თარიღის ფორმატი, სურათების და ვიდეოების ჩამოტვირთვა და სხვა Twitter (X)-სთვის, ხოლო TikTok-სთვის ვიდეოების ჩამოტვირთვა. ის მუდმივად განახლდება და განახლდება, ასე რომ შეგიძლიათ გამოიყენოთ იგი ნდობით.
// @description:ko     이 스크립트는 Twitter (X)와 TikTok을 향상시켜 날짜 형식, 이미지 및 비디오 다운로드 기능 등을 개선하고, TikTok에 대한 비디오 다운로드도 지원합니다. 지속적으로 유지 관리되고 업데이트되므로 안심하고 사용할 수 있습니다.
// @description:nb     Skriptet forbedrer Twitter (X) og TikTok ved å forbedre funksjoner som datoformat, nedlasting av bilder og videoer og mer for Twitter (X), samt videonedlastinger for TikTok. Det vil kontinuerlig vedlikeholdes og oppdateres, slik at du kan bruke det med tillit.
// @description:nl     Het script verbetert Twitter (X) en TikTok door functies zoals datumformaat, beeld- en video-downloads en meer voor Twitter (X) te verbeteren, en videodownloads voor TikTok. Het zal continu worden onderhouden en bijgewerkt, zodat je het met vertrouwen kunt gebruiken.
// @description:pl     Skrypt ulepsza Twitter (X) i TikTok, poprawiając funkcje takie jak format daty, pobieranie obrazów i wideo i inne dla Twitter (X) oraz pobieranie wideo dla TikTok. Będzie ciągle utrzymywany i aktualizowany, dzięki czemu możesz go używać z pewnością.
// @description:pt-BR  O script aprimora o Twitter (X) e o TikTok melhorando recursos como o formato de data, downloads de imagens e vídeos e mais para o Twitter (X), e downloads de vídeos para o TikTok. Ele será mantido e atualizado continuamente, para que você possa usá-lo com confiança.
// @description:ro     Scriptul îmbunătățește Twitter (X) și TikTok prin îmbunătățirea funcțiilor precum formatul datei, descărcarea imaginilor și videoclipurilor și altele pentru Twitter (X) și descărcarea videoclipurilor pentru TikTok. Va fi menținut și actualizat continuu, astfel încât să-l puteți utiliza cu încredere.
// @description:ru     Скрипт улучшает Twitter (X) и TikTok, улучшая такие функции, как формат даты, загрузка изображений и видео и многое другое для Twitter (X), а также загрузку видео для TikTok. Он будет постоянно поддерживаться и обновляться, чтобы вы могли использовать его с уверенностью.
// @description:sk     Skript vylepšuje Twitter (X) a TikTok zlepšením funkcií, ako je formát dátumu, sťahovanie obrázkov a videí a ďalšie pre Twitter (X) a sťahovanie videí pre TikTok. Bude neustále udržiavaný a aktualizovaný, takže ho môžete používať s dôverou.
// @description:sr     Skript unapređuje Twitter (X) i TikTok poboljšanjem funkcija kao što su format datuma, preuzimanje slika i video klipova i drugih za Twitter (X) i preuzimanje video klipova za TikTok. Biće stalno održavan i ažuriran, tako da ga možete koristiti sa poverenjem.
// @description:sv     Skriptet förbättrar Twitter (X) och TikTok genom att förbättra funktioner som datumformat, bild- och videonedladdningar och mer för Twitter (X), samt videonedladdningar för TikTok. Det kommer kontinuerligt att underhållas och uppdateras, så att du kan använda det med förtroende.
// @description:th     สคริปต์นี้ช่วยปรับปรุง Twitter (X) และ TikTok โดยการปรับปรุงฟีเจอร์ต่าง ๆ เช่น รูปแบบวันที่ การดาวน์โหลดภาพและวิดีโอ และอื่น ๆ สำหรับ Twitter (X) และการดาวน์โหลดวิดีโอสำหรับ TikTok จะได้รับการบำรุงรักษาและอัปเดตอย่างต่อเนื่อง ดังนั้นคุณสามารถใช้งานได้อย่างมั่นใจ
// @description:tr     Bu script, Twitter (X) ve TikTok'u tarih formatı, resim ve video indirmeleri gibi özellikleri geliştirerek ve TikTok için video indirmelerini iyileştirerek geliştirir. Sürekli olarak bakım yapılacak ve güncellenmiş olacak, böylece güvenle kullanabilirsiniz.
// @description:uk     Скрипт покращує Twitter (X) та TikTok, вдосконалюючи функції, такі як формат дати, завантаження зображень та відео, а також інші для Twitter (X) та завантаження відео для TikTok. Він буде постійно підтримуватись і оновлюватись, тому ви можете використовувати його з упевненістю.
// @description:ug     بۇ سكىرپت تويتر (X) ۋە TikTokنىڭ مۇنەۋۋەرلىكتىكى خۇسۇسىيەتلەرنى يۇقىرى سەۋىيەگە كۆتۈرۈپ، تويتر (X) ئۈچۈن ۋاقىت تەرتىپى، رەسىم ۋە ۋىدېئو چۈشۈرۈش قاتارلىق خۇسۇسىيەتلەرنى ۋە TikTok ئۈچۈن ۋىدېئو چۈشۈرۈشنى يېڭىلايدۇ. بۇنىڭغا داۋاملىق تەسىر قىلىپ يېڭىلاندۇرۇلۇپ تۇرىدىغان بولىدۇ، شۇڭا ئۇنى ئىشلىتىشكە ئىشەنچىلىك بەلگىلىسىڭىز بولىدۇ.
// @description:vi     Script này cải thiện Twitter (X) và TikTok bằng cách cải thiện các tính năng như định dạng ngày, tải xuống hình ảnh và video, và nhiều hơn nữa cho Twitter (X), và tải xuống video cho TikTok. Nó sẽ được duy trì và cập nhật liên tục, vì vậy bạn có thể sử dụng nó với sự tự tin.
// @namespace   enochLiu_self_script
// @version     1.1.7
// @author      ThalixMurne,PeterParker
// @icon        data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGG0lEQVRogdVaa0xTZxh+z2kb21ItFylFBBfQ2m5iss0s2WTjB9R/M5nEIM450cluDplubnMDnG4zZtnNy5hmZkGRyAgKQyYXRWqMNzTRmBilmzChCIwKGGnp7Tz7ASWtvXh6GeCTfCE957zv9zzne77rgSEXtN1uUx2tqMjT6/XZnZ13Zw8/HCYQyB3M2N9Hr4cK73kZYihCFkGJiUld8+bNq1iRnX1ANV/V5vaQ1WJjGuobc9MWpz0QCAQYy+JZGMb3vXAVP3UIBAKkLU570FDfkGu12JyKiZoam1anJKeM+E48AcQDEJKSnDLS1Ni0moiI2u90JKenpw9OKfI8RKSnpw+23+lIFsQrlZtLS0u1HMeROxiaGmDIGxeDwSBWKBQP2Ta9Pstut3sJCncnDRbeedjtdtLr27LYvr5eFd+gyYN3Pn19fSp2ZMTCTjCbsMFsHmHdyTNTxff+4M6RdbuBqWYdb4Dbix4TMJU6LQ+4vOgn1v/OVhCO/uL39mUyGa1a/SalLlxI58+do98rjpLNZvu/KPoHMGqczEwtr1lRKpXiTIsOTnAch9LDZRCLxbxn1liFAgWbNqOmthZNp5rxeWERZicluT3DMAyefX4Rpsvlj82XkakFbwG569bjUXAccLy6BjKZzG8sy7Io2LQZPb29Hjn6jUZs/HATGIbBfLUG+0p+QX1jE/wuKp0CMjL5C/hh9x6Pyp2orDrmV8S69XmwOxw+4+12O+pO1sNisWJwaAgvLk7jxSkgARnaJbDZbD5J1NTWQiqVesTFz0rA/YEBn3GueDg8jOyclVizdh3e+yA/vAJYlsXOXbv8Eqg9UQe5PNItbnn2CnAcx0tA970e3O3sxPmLlxAdExNeAUQEhmVRsv+AX0InGxoQFRU1HlNYVMSLPADYbDZUVlUhKjo6/BZyFrFYjOqaP/yKaD7TgukzZoCIcLi8nBd5B8dh5ao3IBAKeXMJSgARIUImQ31Do19CzS0t0CxIxRmdzu9zTvQb7yNm5syAeAQtgIgwQy7HqdPNvMjxwZ69+wLmEJIAIoJcHonTzaGLMBi6EadUBiUgpLXQ0NAgLXttGdX9eTKUNFRYXEy9PT3BBYfSAs4ilkhwvLoaPEdLNxwqOxL0cU3IFnIt8shIdBkMAZG/3HoFkS5DbjACwraczi8ooHilkvfzl1tbaenSV2lwYCCkeoUhRRORSCSibTt20GdbPgloR3rocFnwvndFKBZKmTsXtSfq4PCzUPMFk8mEnNdXgQnhuDKoPsCyAjy36AXsKynB4OBQwMRdYR4ZwVt5b4ckwKeFJFIpfbVzF8UrYum+0UisgCWVSkXPLEiluNjYgOxisVqJc3AkkYjdrounTaP9JT+TVCqlvbt/Is/TQR7w1wLSiAgcKjsSlEWcuN2mR9rLr2BD/kafeex2O74oKg7YTrwsJBQKsWbtWnTfuxcQ8faOf7AhP99lmGRQWLzNpwir1Yr3eewBPARk8OwDETIZ8t55F5VVVWj7628Mm83gAHAAbHY7/jUaceXqVfx68CCyc3IwzctemWFZ7Pj6G78t8VIav91YwAJci0QqRXRMDBKS5iBhzlNQKJWQy+UQikSPjRUIBPj2u+99ivh061b+AjK1EAZzmGg2mchsMhEZjQHHOhwO2vLxR/RgaIiKi4pIIHCfSy9cvBRYwtE+MPEfMRiGwbbt22GxWAAADocDP+7ewz8Hw7oOowhMdRgAgL4sLqaqqmOUmppK7e0d1HrpQgAJRofckJcSoQAA3bh+jW5cvxZYIMOOC3jyzkZdyBM9aQJYllztzhARK5GIg5i/JwMMEQdyPVqXSCUcq1DE3ZxEVjzBjB2nuw82CkXcTVajVleKRCLvQVMBTuJwN4pIJCK1Wl1Jhq7uRK1W208+x9zJ/NDN+qxfq9X2G7q6E4mI6KzubJZGrRmeUiL8rEw1Go1JpzubNd4cVouV0el0WVrtkn6R3/XMRAhhfNYjEomg1S7p17Xospz/7OFmdENXd2J5eXnurdu3lvf19T5tNptZjw+Xzp1MuL9ojnvd87JEIuEUiribGrW6Midn5W8Js2d1Ou//B+VuXmLmb0VdAAAAAElFTkSuQmCC
// @include     https://x.com/*
// @include     https://twitter.com/*
// @include     https://mobile.x.com/*
// @include     https://www.tiktok.com/**
// @exclude     *://x.com/i/flow/*
// @license     MIT
// @run-at      document-idle
// @antifeature referral-link
// @noframes
// @grant       GM_registerMenuCommand
// @grant       GM_openInTab
// @grant       GM.openInTab
// @grant       GM_addStyle
// @grant       GM_setValue
// @grant       GM_getValue
// @grant       GM_deleteValue
// @grant       GM_xmlhttpRequest
// @grant       GM_download
// @grant       GM_setClipboard
// @downloadURL https://update.greasyfork.org/scripts/527918/XMaster%3A%20Power%20Tools%20for%20X%20%28Twitter%29.user.js
// @updateURL https://update.greasyfork.org/scripts/527918/XMaster%3A%20Power%20Tools%20for%20X%20%28Twitter%29.meta.js
// ==/UserScript==
(function () {
  'use strict';

  
  /*!
  * Copyright (c) 2024 - 2025, ThalixMurne,PeterParker. All rights reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
  * in the Software without restriction, including without limitation the rights
  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  * copies of the Software, and to permit persons to whom the Software is
  * furnished to do so, subject to the following conditions:
  *
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  *
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
  */


  var css_248z$1 = "li[role=listitem]>div>div>div>div:not(:last-child){filter:none}li[role=listitem]>div>div>div>div+div:last-child{display:none}";

  var css_248z = ".x-master-dl{margin-left:12px;order:99}.x-master-dl:hover>div>div>div>div{color:#1da1f2}.x-master-dl:hover>div>div>div>div>div{background-color:#1da1f21a}.x-master-dl:active>div>div>div>div>div{background-color:#1da1f233}.x-master-dl:hover svg{color:#1da1f2}.x-master-dl:hover div:first-child:not(:last-child){background-color:#1da1f21a}.x-master-dl:active div:first-child:not(:last-child){background-color:#1da1f233}.x-master-dl.tmd-media{position:absolute;right:0}.x-master-dl.tmd-media>div{border-radius:99px;display:flex;margin:2px}.x-master-dl.tmd-media>div>div{color:#fff;display:flex;margin:6px}.x-master-dl.tmd-media:hover>div{background-color:#fff9}.x-master-dl.tmd-media:hover>div>div{color:#1da1f2}.x-master-dl.tmd-media:not(:hover)>div>div{filter:drop-shadow(0 0 1px #000)}.x-master-dl g{display:none}.x-master-dl.completed g.completed,.x-master-dl.download g.download,.x-master-dl.failed g.failed,.x-master-dl.loading g.loading{display:unset}.x-master-dl.loading svg{animation:spin 1s linear infinite}.x-master-dl.download g.download{color:#1da1f2}.tmd-btn{background-color:#1da1f2;border-radius:99px;color:#fff;padding:0 20px}.tmd-btn,.tmd-tag{display:inline-block}.tmd-tag{background-color:#fff;border:1px solid #1da1f2;border-radius:10px;color:#1da1f2;font-weight:700;margin:5px;padding:0 10px}.tmd-btn:hover{background-color:#1da1f2e6}.tmd-tag:hover{background-color:#1da1f21a}.tmd-notifier{background:#fff;border:1px solid #ccc;border-radius:8px;bottom:16px;color:#000;display:none;left:16px;padding:4px;position:fixed}.tmd-notifier.running{align-items:center;display:flex}.tmd-notifier label{align-items:center;display:inline-flex;margin:0 8px}.tmd-notifier label:before{background-position:50%;background-repeat:no-repeat;content:\" \";height:16px;width:32px}.tmd-notifier label:first-child:before{background-image:url(\"data:image/svg+xml;charset=utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%2216%22 height=%2216%22 viewBox=%220 0 24 24%22><path d=%22M3,14 v5 q0,2 2,2 h14 q2,0 2,-2 v-5 M7,10 l4,4 q1,1 2,0 l4,-4 M12,3 v11%22 fill=%22none%22 stroke=%22%23666%22 stroke-width=%222%22 stroke-linecap=%22round%22 /></svg>\")}.tmd-notifier label:nth-child(2):before{background-image:url(\"data:image/svg+xml;charset=utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%2216%22 height=%2216%22 viewBox=%220 0 24 24%22><path d=%22M12,2 a1,1 0 0 1 0,20 a1,1 0 0 1 0,-20 M12,5 v7 h6%22 fill=%22none%22 stroke=%22%23999%22 stroke-width=%222%22 stroke-linejoin=%22round%22 stroke-linecap=%22round%22 /></svg>\")}.tmd-notifier label:nth-child(3):before{background-image:url(\"data:image/svg+xml;charset=utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%2216%22 height=%2216%22 viewBox=%220 0 24 24%22><path d=%22M12,0 a2,2 0 0 0 0,24 a2,2 0 0 0 0,-24%22 fill=%22%23f66%22 stroke=%22none%22 /><path d=%22M14.5,5 a1,1 0 0 0 -5,0 l0.5,9 a1,1 0 0 0 4,0 z M12,17 a2,2 0 0 0 0,5 a2,2 0 0 0 0,-5%22 fill=%22%23fff%22 stroke=%22none%22 /></svg>\")}.x-master-dl.tmd-img{bottom:0;display:none!important;position:absolute;right:0}.x-master-dl.tmd-img>div{background-color:#fff9;border-radius:99px;display:flex;margin:2px}.x-master-dl.tmd-img>div>div{color:#fff!important;display:flex;margin:6px}.x-master-dl.tmd-img:not(:hover)>div>div{filter:drop-shadow(0 0 1px #000)}.x-master-dl.tmd-img:hover>div>div{color:#1da1f2}.tmd-img.completed,.tmd-img.failed,.tmd-img.loading,:hover>.x-master-dl.tmd-img{display:block!important}.tweet-detail-action-item{width:20%!important}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}";

  const ScriptConst = {
    "lang": (navigator.language || navigator.userLanguage || "").slice(0, 2).toLowerCase() || "en",
    "isDev": false,
    "isDebug": false,
    "version": "1.0.1",
    "number": "11",
    "currentHost": window.location.host,
    "currentUrl": window.location.href
  };
  const PlatformConst = {
    "x": { "p": "x", "match": /twitter|x\.com$/ },
    "youtube": { "p": "youtube", "match": /youtube\.com$/ },
    "tiktok": { "p": "tiktok", "match": /www\.tiktok\.com/ },
    "cobalt": { "p": "cobalt", "match": /cobalt\.tools/ }
  };

  var __async$2 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  const Tools = {
    decryptStr: function(str) {
      try {
        if (!str) {
          return str;
        }
        let result = atob(str);
        return result.split("").reverse().join("");
      } catch (e) {
      }
      return null;
    },
    encryptStr: function(str) {
      try {
        if (!str) {
          return str;
        }
        let result = str.split("").reverse().join("");
        return btoa(result);
      } catch (e) {
      }
      return null;
    },
    getOtherPlatform: function() {
      let platform = null;
      const currentHost = window.location.host;
      for (let key in PlatformConst) {
        if (PlatformConst[key].match.test(currentHost)) {
          platform = PlatformConst[key].p;
          break;
        }
      }
      return platform;
    },
    removeAnchorsByNode: function(node) {
      const tagName = node.tagName;
      if (!tagName)
        return;
      const exist = ["A", "IMG", "DIV", "SPAN", "LABEL", "TABLE", "TR", "TD", "CANVAS"].some((name) => name === tagName);
      if (exist) {
        node.removeAttribute("data-spm-anchor-id");
        for (let i = 0; i < node.childNodes.length; i++) {
          this.removeAnchorsByNode(node.childNodes[i]);
        }
      }
    },
    openInTab: function(url, options = { "active": true, "insert": true, "setParent": true }) {
      if (typeof GM_openInTab === "function") {
        GM_openInTab(url, options);
      } else {
        GM.openInTab(url, options);
      }
    },
    onPageLoad: function(callback) {
      if (document.readyState === "complete") {
        callback();
      } else {
        window.addEventListener("DOMContentLoaded", callback, { once: true });
        window.addEventListener("load", callback, { once: true });
      }
    },
    request: function(method, url, param, headers = { "Content-Type": "application/json;charset=UTF-8" }, timeout = 20 * 1e3) {
      if (!url) {
        return Promise.reject({ "code": "exception", "result": null });
      }
      return new Promise((resolve, reject) => {
        const config = {
          method: method.toUpperCase(),
          url,
          timeout,
          onload: function(response) {
            if (response.status >= 200 && response.status < 300) {
              resolve({ "code": "success", "result": response.responseText });
            } else {
              reject({ "code": "error", "result": response.statusText });
            }
          },
          ontimeout: function(error) {
            reject({ "code": "error", "result": error });
          },
          onerror: function(error) {
            reject({ "code": "error", "result": error });
          }
        };
        if (config.method === "POST") {
          config.headers = headers != null ? headers : { "Content-Type": "application/json" };
          if (JSON.stringify(config.headers).indexOf("application/json") != -1) {
            config.data = JSON.stringify(param);
          } else {
            config.data = param;
          }
        } else if (config.method === "GET") {
          config.headers = headers != null ? headers : { "Content-Type": "application/json" };
          config.data = param;
        }
        GM_xmlhttpRequest(config);
      });
    },
    crossRequest: function(method = "GET", url, param = {}, headers = { "Content-Type": "application/json;charset=UTF-8" }, timeout = 20 * 1e3) {
      if (!url) {
        return Promise.reject({ "code": "exception", "result": null });
      }
      const config = { method: method.toUpperCase(), headers };
      const controller = new AbortController();
      const signal = controller.signal;
      config.signal = signal;
      if (config.method === "POST") {
        config.headers = headers != null ? headers : { "Content-Type": "application/json" };
        config.body = JSON.stringify(param);
      }
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      return fetch(url, config).then((response) => response.ok ? response.text() : Promise.reject(response.statusText)).then((result) => {
        clearTimeout(timeoutId);
        return { "code": "success", "result": result };
      }).catch((error) => {
        clearTimeout(timeoutId);
        if (error.name === "AbortError") {
          return { "code": "error", "result": "Request timeout" };
        }
        return { "code": "error", "result": error };
      });
    },
    getGoodsIdByLink: function(url = window.location.href) {
      if (url.indexOf("?") != -1) {
        url = url.split("?")[0];
      }
      if (url.indexOf("#") != -1) {
        url = url.split("#")[0];
      }
      const suffix = "html|htm|id|p";
      let regex = new RegExp("\\/([^\\/]*?)\\.(" + suffix + ")");
      if (/lazada\./.test(url)) {
        regex = new RegExp("-i(\\d+)(?:-s(\\d+))?\\.html");
      } else if (/ebay\./.test(url)) {
        regex = new RegExp("\\/itm\\/(\\d+)");
      } else if (/banggood\./.test(url)) {
        regex = new RegExp("-p-(\\d+)\\.html");
      }
      const match = url.match(regex);
      return match ? match[1] : null;
    },
    getParamterBySearch: function(paramsString = window.location.href, tag) {
      if (paramsString.indexOf("?") != -1) {
        paramsString = paramsString.split("?")[1];
      }
      const params = new URLSearchParams(paramsString);
      return params.get(tag);
    },
    waitForElementByInterval: function(selector, target = document.body, allowEmpty = true, delay = 10, maxDelay = 10 * 1e3) {
      return new Promise((resolve, reject) => {
        let totalDelay = 0;
        let element = target.querySelector(selector);
        let result = allowEmpty ? !!element : !!element && !!element.innerHTML;
        if (result) {
          resolve(element);
        }
        const elementInterval = setInterval(() => {
          if (totalDelay >= maxDelay) {
            clearInterval(elementInterval);
            resolve(null);
          }
          element = target.querySelector(selector);
          result = allowEmpty ? !!element : !!element && !!element.innerHTML;
          if (result) {
            clearInterval(elementInterval);
            resolve(element);
          } else {
            totalDelay += delay;
          }
        }, delay);
      });
    },
    randomNumber: function() {
      return Math.ceil(Math.random() * 1e8);
    },
    elementInContainer: function(container, element) {
      return container.contains(element);
    },
    mustGetElement: function(handler) {
      return __async$2(this, null, function* () {
        const getElements = (handler2) => __async$2(this, null, function* () {
          const promiseArray = [];
          const handlers = handler2.split("@");
          for (let i = 0; i < handlers.length; i++) {
            const eleName = handlers[i];
            if (!eleName) {
              continue;
            }
            if (eleName == "body") {
              promiseArray.push(
                new Promise((resolve, reject) => {
                  resolve(document.body);
                })
              );
            } else if (eleName == "html") {
              promiseArray.push(
                new Promise((resolve, reject) => {
                  resolve(document.html);
                })
              );
            } else {
              promiseArray.push(this.waitForElementByInterval(eleName, document.body, true, 10, 1500));
            }
          }
          let element2 = yield Promise.race(promiseArray);
          return element2;
        });
        let element = yield getElements(handler);
        return new Promise((resolve, reject) => {
          if (element) {
            resolve(element);
            return;
          }
          const waitInterval = setInterval(() => {
            element = getElements(handler);
            if (element) {
              clearInterval(waitInterval);
              resolve(element);
              return;
            }
          }, 2e3);
        });
      });
    },
    loopTask: function(callback, delay = 1500) {
      callback();
      setInterval(() => {
        callback();
      }, delay);
    },
    distinguishRemoveAndTry: function(distinguish, callback) {
      const distinguishElements = distinguish.map((name) => document.querySelector("*[name='" + name + "']"));
      const validateRs = distinguishElements.some((ele) => ele === null || ele === void 0);
      if (validateRs) {
        distinguishElements.reverse().forEach((element) => {
          if (element) {
            element.remove();
          }
        });
        callback();
      }
    },
    getDomain: function(url) {
      try {
        const hostname = new URL(url).hostname;
        const parts = hostname.split(".");
        if (parts.length > 2) {
          return `${parts[parts.length - 2]}.${parts[parts.length - 1]}`;
        }
        return hostname;
      } catch (error) {
        return null;
      }
    },
    getCommonMarketplace: function(url = window.location.href) {
      try {
        const domainParts = new URL(url).hostname.split(".");
        const countryCode = domainParts[domainParts.length - 1];
        return countryCode;
      } catch (error) {
      }
      return null;
    }
  };

  var _a;
  const language = {
    "zh": {
      "dateFormat": {
        "week": ["日", "一", "二", "三", "四", "五", "六"]
      },
      "download": {
        "download": "下载",
        "completed": "下载完成",
        "tip": "点击下载视频",
        "preparing": "正在准备下载（如果失败，请手动操作）"
      },
      "menuCommand": {
        "settings": "设置",
        "titleDateFormat": "时间格式设置：",
        "buttonClose": "关闭"
      }
    },
    "en": {
      "dateFormat": {
        "week": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
      },
      "download": {
        "download": "Download",
        "completed": "Download Completed",
        "tip": "Click to download video",
        "preparing": "Preparing to download (if failed, please do it manually)"
      },
      "menuCommand": {
        "settings": "Settings",
        "titleDateFormat": "Time format settings:",
        "buttonClose": "Close"
      }
    },
    "ja": {
      "dateFormat": {
        "week": ["日", "月", "火", "水", "木", "金", "土"]
      },
      "download": {
        "download": "ダウンロード",
        "completed": "ダウンロード完了",
        "tip": "クリックしてビデオをダウンロード",
        "preparing": "ダウンロードの準備中（失敗する場合は手動で行ってください）"
      },
      "menuCommand": {
        "settings": "設定",
        "titleDateFormat": "時刻形式の設定:",
        "buttonClose": "閉鎖"
      }
    },
    "fr": {
      "dateFormat": {
        "week": ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"]
      },
      "download": {
        "download": "télécharger",
        "completed": "éléchargement terminé",
        "tip": "Cliquez pour télécharger la vidéo",
        "preparing": "Préparation du téléchargement (en cas d'échec, veuillez le faire manuellement)"
      },
      "menuCommand": {
        "settings": "installation",
        "titleDateFormat": "Paramètres du format de l'heure :",
        "buttonClose": "fermeture"
      }
    },
    "de": {
      "dateFormat": {
        "week": ["Son", "Mon", "Die", "Mit", "Don", "Fre", "Sam"]
      },
      "download": {
        "download": "herunterladen",
        "completed": "Download abgeschlossen",
        "tip": "Klicken Sie hier, um das Video herunterzuladen",
        "preparing": "Vorbereitung für den Download (falls der Download fehlschlägt, führen Sie ihn bitte manuell durch)"
      },
      "menuCommand": {
        "settings": "aufstellen",
        "titleDateFormat": "Einstellungen für das Zeitformat:",
        "buttonClose": "Schließung"
      }
    },
    "it": {
      "dateFormat": {
        "week": ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"]
      },
      "download": {
        "download": "scaricamento",
        "completed": "Download completato",
        "tip": "Fare clic per scaricare il video",
        "preparing": "Preparazione per il download (se fallisce, eseguilo manualmente)"
      },
      "menuCommand": {
        "settings": "impostare",
        "titleDateFormat": "Impostazioni del formato dell'ora:",
        "buttonClose": "chiusura"
      }
    },
    "ko": {
      "dateFormat": {
        "week": ["일", "월", "화", "수", "목", "금", "토"]
      },
      "download": {
        "download": "다운로드",
        "completed": "다운로드 완료",
        "tip": "비디오를 다운로드하려면 클릭하세요",
        "preparing": "다운로드 준비 중 (실패할 경우 수동으로 진행해주세요)"
      },
      "menuCommand": {
        "settings": "설정",
        "titleDateFormat": "시간 형식 설정:",
        "buttonClose": "폐쇄"
      }
    },
    "ru": {
      "dateFormat": {
        "week": ["ВС", "ПН", "ВТ", "СР", "ЧТ", "ПТ", "СБ"]
      },
      "download": {
        "download": "скачать",
        "completed": "Загрузка завершена",
        "tip": "Нажмите, чтобы скачать видео",
        "preparing": "Подготовка к загрузке (если не получается, сделайте это вручную)"
      },
      "menuCommand": {
        "settings": "настраивать",
        "titleDateFormat": "Настройки формата времени:",
        "buttonClose": "закрытие"
      }
    },
    "pt": {
      "dateFormat": {
        "week": ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"]
      },
      "download": {
        "download": "descargar",
        "completed": "Descarga completa",
        "tip": "Clique para baixar o vídeo",
        "preparing": "Preparação para download (se falhar, faça-o manualmente)"
      },
      "menuCommand": {
        "settings": "configuración",
        "titleDateFormat": "Configuración de formato de hora:",
        "buttonClose": "cierre"
      }
    },
    "es": {
      "dateFormat": {
        "week": ["DOM", "LUN", "MAR", "MIER", "JUE", "VIE", "SÁB"]
      },
      "download": {
        "download": "descargar",
        "completed": "Descarga completa",
        "tip": "Haga clic para descargar el vídeo",
        "preparing": "Preparándose para la descarga (si falla, hágalo manualmente)"
      },
      "menuCommand": {
        "settings": "configuración",
        "titleDateFormat": "Configuración de formato de hora:",
        "buttonClose": "cierre"
      }
    },
    "th": {
      "dateFormat": {
        "week": ["วันอาทิตย์", "วันจันทร์", "วันอังคาร", "วันพุธ", " วันพฤหัสบดี", "วันศุกร์ ", "วันเสาร์ "]
      },
      "download": {
        "download": "ดาวน์โหลด",
        "completed": "ดาวน์โหลดเสร็จสมบูรณ์",
        "tip": "คลิกเพื่อดาวน์โหลดวิดีโอ",
        "preparing": "กำลังเตรียมการดาวน์โหลด (หากล้มเหลว กรุณาดำเนินการด้วยตนเอง)"
      },
      "menuCommand": {
        "settings": "ตั้งค่า",
        "titleDateFormat": "การตั้งค่ารูปแบบเวลา：",
        "buttonClose": "ปิด"
      }
    },
    "tr": {
      "dateFormat": {
        "week": ["Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"]
      },
      "download": {
        "download": "indirmek",
        "completed": "İndirme tamamlandı",
        "tip": "Videoyu indirmek için tıklayın",
        "preparing": "İndirmeye hazırlanıyor (başarısız olursa lütfen manuel olarak yapın)"
      },
      "menuCommand": {
        "settings": "kurmak",
        "titleDateFormat": "Saat formatı ayarları：",
        "buttonClose": "kapatma"
      }
    },
    "nl": {
      "dateFormat": {
        "week": ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"]
      },
      "download": {
        "download": "downloaden",
        "completed": "Downloaden voltooid",
        "tip": "Klik om video te downloaden",
        "preparing": "Voorbereiden voor downloaden (als dit mislukt, doe dit dan handmatig)"
      },
      "menuCommand": {
        "settings": "opgezet",
        "titleDateFormat": "Instellingen tijdformaat:",
        "buttonClose": "sluiting"
      }
    }
  };
  const Commonlanguage = (_a = language[ScriptConst["lang"]]) != null ? _a : language["en"];

  var __async$1 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  const FMT = 3;
  let fmt = GM_getValue("fmt", FMT);
  const XSettingsDialog = {
    number: Math.ceil(Math.random() * 1e8),
    formats: [
      { "format": "Do nothing", "example": "N/A" },
      { "format": "yyyy-MM-dd'T'HH:mm:ss", "example": "2025-07-09T22:57:30" },
      { "format": "mmmm d, yyyy hh:mm A", "example": "July 9, 2025 10:57 PM" },
      { "format": "hh:mm A mmm d, yyyy", "example": "10:57 PM Jul 9, 2025" },
      { "format": "HH.mmA·mmm d,yy", "example": "10.57PM·jul 9,25" },
      { "format": "MM/dd/yy HH:mm", "example": "07/09/25 22:57" },
      { "format": "MM/dd/yy HH:mm:ss", "example": "07/09/25 22:57:30" },
      { "format": "W, MM/dd/yy HH:mm", "example": "Wed, 07/09/25 22:57" },
      { "format": "W, MM/dd/yy HH:mm:ss", "example": "Wed, 07/09/25 22:57:30" },
      { "format": "dd.MM.yy HH:mm", "example": "09.07.25 22:57" },
      { "format": "dd.MM.yy HH:mm:ss", "example": "09.07.25 22:57:30" },
      { "format": "dd.MM.yy(W) HH:mm", "example": "09.07.25(Wed) 22:57" },
      { "format": "dd.MM.yy(W) HH:mm:ss", "example": "09.07.25(Wed) 22:57:30" },
      { "format": "yy/MM/dd HH:mm", "example": "25/07/09 22:57" },
      { "format": "yy/MM/dd HH:mm:ss", "example": "25/07/09 22:57:30" },
      { "format": "yy/MM/dd(W) HH:mm", "example": "25/07/09(Wed) 22:57" },
      { "format": "yy/MM/dd(W) HH:mm:ss [ye/mo/da(we) ho:mi:se]", "example": "25/07/09(Wed) 22:57:30 [ye/mo/da(we) ho:mi:se]" },
      { "format": "yy-MM/dd HH:mm", "example": "25-07/09 22:57" },
      { "format": "yy-MM/dd HH:mm'ss", "example": "25-07/09 22:57'30" },
      { "format": "yy-MM/dd(W) HH:mm", "example": "25-07/09(Wed) 22:57" },
      { "format": "yy-MM/dd(W) HH:mm'ss", "example": "25-07/09(Wed) 22:57'30" },
      { "format": "M114-MM-dd HH:mm", "example": "M114-07-09 22:57" },
      { "format": "M114-MM-dd HH:mm:ss", "example": "M114-07-09 22:57:30" },
      { "format": "M114-MM-dd(W) HH:mm", "example": "M114-07-09(Wed) 22:57" },
      { "format": "M114-MM-dd(W) HH:mm:ss", "example": "M114-07-09(Wed) 22:57:30" },
      { "format": "W, mmmm d, yyyy hh:mm:ss A", "example": "Wednesday, July 9, 2025 10:57:30 PM" }
    ],
    make: function() {
      let dialog = document.createElement("div");
      dialog.className = "dialog_u_" + this.number;
      dialog.style.all = "initial";
      dialog.style.backgroundColor = "rgb(255, 255, 255)";
      dialog.style.border = "1px solid #ccc";
      dialog.style.borderRadius = "2px";
      dialog.style.display = "none";
      dialog.style.fontFamily = "monospace";
      dialog.style.fontSize = "12px";
      dialog.style.width = "480px";
      dialog.style.paddingLeft = "5px";
      dialog.style.paddingRight = "5px";
      dialog.style.paddingTop = "5px";
      dialog.style.paddingBottom = "5px";
      dialog.style.position = "fixed";
      dialog.style.right = "8px";
      dialog.style.top = "8px";
      dialog.style.zIndex = "2147483647";
      dialog.style.overflow = "auto";
      let formatsHtml = `<table style="width:100%;border: 1px solid #c0bfbf;border-collapse: collapse;">`;
      for (var i = 1; i <= this.formats.length; i++) {
        if (i % 2 != 0) {
          formatsHtml += `<tr style="width:100%;border: 1px solid #c0bfbf;">`;
        }
        formatsHtml += `<td width="50" style="border: 1px solid #c0bfbf;padding: 5px;" title="` + this.formats[i - 1].example + `"><input type="radio" name="fmt" value="` + (i - 1) + `" class="top_r" />` + ("【" + i + "】" + this.formats[i - 1].format) + `</td>`;
        if (i % 2 == 0) {
          formatsHtml += `</tr>`;
        }
      }
      formatsHtml += `</table>`;
      let html = `
        <div style="font-size:15px;font-weight:bold;margin-bottom:5px;">` + Commonlanguage.menuCommand.titleDateFormat + `</div>
        <div>` + formatsHtml + `</div>
        <div style="margin-top:15px;text-align:center;">
          <button name="closex">` + Commonlanguage.menuCommand.buttonClose + `</button>
        </div>
      `;
      dialog.innerHTML = html;
      return dialog;
    },
    addEvent: function(dialog) {
      dialog.querySelector("button[name='closex']").addEventListener("click", function(event) {
        for (let e of dialog.querySelectorAll('input[name="fmt"]')) {
          if (e.checked) {
            fmt = e.value;
            break;
          }
        }
        GM_setValue("fmt", fmt);
        dialog.style.display = "none";
      }, false);
    },
    init: function() {
      let dialog = this.make();
      this.addEvent(dialog);
      document.body.appendChild(dialog);
      GM_registerMenuCommand(Commonlanguage.menuCommand.settings, function() {
        if (dialog.style.display == "none") {
          dialog.querySelector('input[name="fmt"][value="' + fmt + '"]').checked = true;
          dialog.style.display = "block";
        }
      });
    }
  };
  const XDateFormat = {
    df: function(date, f) {
      var _a;
      const WEEK = Commonlanguage.dateFormat.week;
      const WEEK_FULL = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      const MONTH_SHORT = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      const MONTH_FULL = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      const pad = (num) => ("0" + num).slice(-2);
      const YE = date.getFullYear();
      const YE2 = YE.toString().slice(-2);
      const YM = YE - 1911;
      const MO = pad(date.getMonth() + 1);
      const MO_IDX = date.getMonth();
      const MO_NAME = MONTH_SHORT[MO_IDX];
      const MO_NAME_FULL = MONTH_FULL[MO_IDX];
      const DA = pad(date.getDate());
      const WE = WEEK[date.getDay()];
      const WE_FULL = WEEK_FULL[date.getDay()];
      const HO = pad(date.getHours());
      const MI = pad(date.getMinutes());
      const SE = pad(date.getSeconds());
      const h12 = date.getHours() % 12 || 12;
      const HO12 = pad(h12);
      const AMPM = date.getHours() >= 12 ? "PM" : "AM";
      const F = [
        `${YE}-${MO}-${DA}T${HO}:${MI}:${SE}`,
        `${MO_NAME_FULL} ${parseInt(DA)}, ${YE} ${HO12}:${MI} ${AMPM}`,
        `${HO12}:${MI} ${AMPM} ${MO_NAME} ${parseInt(DA)}, ${YE}`,
        `${HO12}.${MI}${AMPM}·${MO_NAME.toLowerCase()} ${parseInt(DA)},${YE2}`,
        `${MO}/${DA}/${YE2} ${HO}:${MI}`,
        `${MO}/${DA}/${YE2} ${HO}:${MI}:${SE}`,
        `${WE}, ${MO}/${DA}/${YE2} ${HO}:${MI}`,
        `${WE}, ${MO}/${DA}/${YE2} ${HO}:${MI}:${SE}`,
        `${DA}.${MO}.${YE2} ${HO}:${MI}`,
        `${DA}.${MO}.${YE2} ${HO}:${MI}:${SE}`,
        `${DA}.${MO}.${YE2}(${WE}) ${HO}:${MI}`,
        `${DA}.${MO}.${YE2}(${WE}) ${HO}:${MI}:${SE}`,
        `${YE2}/${MO}/${DA} ${HO}:${MI}`,
        `${YE2}/${MO}/${DA} ${HO}:${MI}:${SE}`,
        `${YE2}/${MO}/${DA}(${WE}) ${HO}:${MI}`,
        `${YE2}/${MO}/${DA}(${WE}) ${HO}:${MI}:${SE} [ye/mo/da(we) ho:mi:se]`,
        `${YE2}-${MO}/${DA} ${HO}:${MI}`,
        `${YE2}-${MO}/${DA} ${HO}:${MI}'${SE}`,
        `${YE2}-${MO}/${DA}(${WE}) ${HO}:${MI}`,
        `${YE2}-${MO}/${DA}(${WE}) ${HO}:${MI}'${SE}`,
        `M${YM}-${MO}-${DA} ${HO}:${MI}`,
        `M${YM}-${MO}-${DA} ${HO}:${MI}:${SE}`,
        `M${YM}-${MO}-${DA}(${WE}) ${HO}:${MI}`,
        `M${YM}-${MO}-${DA}(${WE}) ${HO}:${MI}:${SE}`,
        `${WE_FULL}, ${MO_NAME_FULL} ${parseInt(DA)}, ${YE} ${HO12}:${MI}:${SE} ${AMPM}`
      ];
      return (_a = F[f]) != null ? _a : F[0];
    },
    repldatetime: function() {
      const MYNAME = "peter_parker_x1190";
      const SEL = 'main div[data-testid="primaryColumn"] section article time[datetime*=":"]';
      const SEL_2 = 'div[aria-labelledby="modal-header"] div[data-testid^="User-Name"] time[datetime]';
      const SEL_3 = 'div[aria-labelledby="modal-header"] div[aria-label] time[datetime]';
      const SEL_4 = 'main section[aria-labelledby="detail-header"] article div[data-testid^="User-Name"] time[datetime]';
      const SEL_5 = 'main section div[data-testid="conversation"] div[aria-label] time[datetime]';
      document.querySelectorAll(SEL + ", " + SEL_2 + ", " + SEL_3 + ", " + SEL_4 + ", " + SEL_5).forEach((e) => {
        if (fmt != 0) {
          const SEL_ADD = "span.us-" + MYNAME;
          let d = e.getAttribute("datetime");
          let df = this.df(new Date(d), fmt - 1);
          let pe = e.parentNode;
          let old = pe.querySelectorAll(SEL_ADD);
          if (!old.length) {
            let span = document.createElement("span");
            span.className = "us-" + MYNAME;
            span.setAttribute("datetime", d);
            span.setAttribute("local-datetime", df);
            span.textContent = df;
            span.style = e.style;
            e.style.setProperty("display", "none");
            pe.appendChild(span);
          } else if (old[0].getAttribute("local-datetime") != df) {
            old[0].setAttribute("local-datetime", df);
            old[0].textContent = df;
            old[0].style = e.style;
          }
        }
      });
    }
  };
  const XDownload = {
    mediaMap: {},
    showSensitive: true,
    svg: `
      <g class="download"><path d="M11.99 16l-5.7-5.7L7.7 8.88l3.29 3.3V2.59h2v9.59l3.3-3.3 1.41 1.42-5.71 5.7zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z" /></g>
      <g class="completed"><path d="M3,14 v5 q0,2 2,2 h14 q2,0 2,-2 v-5 M7,10 l3,4 q1,1 2,0 l8,-11" fill="none" stroke="#1DA1F2" stroke-width="2" stroke-linecap="round" /></g>
      <g class="loading"><circle cx="12" cy="12" r="10" fill="none" stroke="#1DA1F2" stroke-width="4" opacity="0.4" /><path d="M12,2 a10,10 0 0 1 10,10" fill="none" stroke="#1DA1F2" stroke-width="4" stroke-linecap="round" /></g>
      <g class="failed"><circle cx="12" cy="12" r="11" fill="#f33" stroke="currentColor" stroke-width="2" opacity="0.8" /><path d="M14,5 a1,1 0 0 0 -4,0 l0.5,9.5 a1.5,1.5 0 0 0 3,0 z M12,17 a2,2 0 0 0 0,4 a2,2 0 0 0 0,-4" fill="#fff" stroke="none" /></g>
    `,
    isTweetdeck: function() {
      return window.location.host.indexOf("tweetdeck") >= 0;
    },
    formatDate: function(i, o, tz) {
      let d = new Date(i);
      if (tz) {
        d.setMinutes(d.getMinutes() - d.getTimezoneOffset());
      }
      let m = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
      let v = {
        YYYY: d.getUTCFullYear().toString(),
        YY: d.getUTCFullYear().toString(),
        MM: d.getUTCMonth() + 1,
        MMM: m[d.getUTCMonth()],
        DD: d.getUTCDate(),
        hh: d.getUTCHours(),
        mm: d.getUTCMinutes(),
        ss: d.getUTCSeconds(),
        h2: d.getUTCHours() % 12,
        ap: d.getUTCHours() < 12 ? "AM" : "PM"
      };
      return o.replace(/(YY(YY)?|MMM?|DD|hh|mm|ss|h2|ap)/g, (n) => ("0" + v[n]).substr(-n.length));
    },
    detect: function(node) {
      let article = node.tagName == "ARTICLE" && node || node.tagName == "DIV" && (node.querySelector("article") || node.closest("article"));
      if (article) {
        this.addButtonTo(article);
      }
      let listitems = node.tagName == "LI" && node.getAttribute("role") == "listitem" && [node] || node.tagName == "DIV" && node.querySelectorAll('li[role="listitem"]');
      if (listitems) {
        this.addButtonToMedia(listitems);
      }
    },
    extractStatusId: function(url) {
      if (!url)
        return null;
      const match = url.match(/\/status\/(\d+)/);
      return match ? match[1] : null;
    },
    uniqueArray: function(arr) {
      var result = [];
      var seen = {};
      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        if (!seen[item]) {
          result.push(item);
          seen[item] = true;
        }
      }
      return result;
    },
    getExtension: function(url) {
      const pathname = new URL(url).pathname;
      const parts = pathname.split(".");
      return parts.length > 1 ? parts.pop() : null;
    },
    sanitizeFilename: function(filename) {
      return filename.replace(/[\/\\\?\%\*\:\|\\"<>\r\n]/g, "_");
    },
    status: function(btn, classnames, title, style) {
      if (classnames) {
        btn.classList.remove("download", "completed", "loading", "failed");
        btn.classList.add(...classnames);
      }
      if (title) {
        btn.title = title;
      }
      if (style) {
        btn.style.cssText = style;
      }
    },
    clickDownloadEvent: function(btn, statusIds) {
      statusIds = this.uniqueArray(statusIds);
      if (btn.classList.contains("loading")) {
        return;
      }
      this.status(btn, ["loading"]);
      const handleDownload = (url, filename, defaultExt) => {
        return new Promise((resolve, reject) => {
          var _a;
          GM_download({
            url,
            name: filename + "." + ((_a = this.getExtension(url)) != null ? _a : defaultExt),
            onload: function() {
              resolve();
            },
            onerror: function(error) {
              reject();
            }
          });
        });
      };
      const filenameTemplate = "{name}";
      const validMediaTasks = statusIds.map((statusId) => {
        var _a;
        const media = this.mediaMap[statusId];
        if (!media)
          return null;
        const { entityId, id, thumbnail, video, photo, text } = media;
        const filename = filenameTemplate.replace("{name}", (_a = this.sanitizeFilename(text)) != null ? _a : entityId);
        return () => new Promise((resolve) => {
          setTimeout(() => {
            if (video)
              handleDownload(video, filename, "mp4");
            if (!video && photo)
              handleDownload(photo, filename, "jpg");
            resolve(true);
          }, 700);
        });
      }).filter(Boolean);
      if (validMediaTasks.length === 0) {
        this.status(btn, ["failed"]);
        return;
      }
      Promise.allSettled(validMediaTasks.map((fn) => fn())).then((results) => {
        this.status(btn, ["completed"]);
      });
    },
    addButtonTo: function(article) {
      if (article.dataset.detected) {
        return;
      }
      article.dataset.detected = "true";
      const statusElements = Array.from(article.querySelectorAll('a[href*="/status/"]'));
      const statusIds = statusElements.map((el) => this.extractStatusId(el.href)).filter((id) => id);
      if (statusIds.length === 0) {
        return;
      }
      const mediaSelector = [
        'a[href*="/photo/1"]',
        'div[role="progressbar"]',
        'button[data-testid="playButton"]',
        'div[data-testid="videoComponent"]',
        'a[href="/settings/content_you_see"]',
        "div.media-image-container",
        "div.media-preview-container",
        'div[aria-labelledby]>div:first-child>div[role="button"][tabindex="0"]'
      ];
      const media = article.querySelector(mediaSelector.join(","));
      if (media) {
        const btnGroup = article.querySelector('div[role="group"]:last-of-type, ul.tweet-actions, ul.tweet-detail-actions');
        if (btnGroup) {
          const btnShare = Array.from(btnGroup.querySelectorAll(":scope>div>div, li.tweet-action-item>a, li.tweet-detail-action-item>a")).pop().parentNode;
          const btnDownload = btnShare.cloneNode(true);
          btnDownload.style.marginLeft = "10px";
          btnDownload.querySelector("button").removeAttribute("disabled");
          if (this.isTweetdeck()) {
            btnDownload.firstElementChild.innerHTML = '<svg viewBox="0 0 20 20" width="15" height="15">' + this.svg + "</svg>";
            btnDownload.firstElementChild.removeAttribute("rel");
            btnDownload.classList.replace("pull-left", "pull-right");
          } else {
            btnDownload.querySelector("svg").innerHTML = this.svg;
          }
          this.status(btnDownload, ["x-master-dl", "download"]);
          btnGroup.insertBefore(btnDownload, btnShare.nextSibling);
          btnDownload.onclick = () => {
            this.clickDownloadEvent(btnDownload, statusIds);
          };
          if (this.showSensitive) {
            let showSensitiveBtn = article.querySelector('div[aria-labelledby] div[role="button"][tabindex="0"]:not([data-testid]) > div[dir] > span > span');
            if (showSensitiveBtn) {
              showSensitiveBtn.click();
            }
          }
        }
      }
      const imgs = article.querySelectorAll('a[href*="/photo/"]');
      if (imgs.length > 1) {
        imgs.forEach((img) => {
          let statusId = this.extractStatusId(img.src);
          if (!statusId) {
            return;
          }
          let btnDownload = document.createElement("div");
          btnDownload.style.marginLeft = "10px";
          btnDownload.innerHTML = '<div><div><svg viewBox="0 0 20 20" width="15" height="15">' + this.svg + "</svg></div></div>";
          this.status(btnDownload, ["x-master-dl", "tmd-img", "download"]);
          img.parentNode.appendChild(btnDownload);
          btnDownload.onclick = (e) => {
            e.preventDefault();
            this.clickDownloadEvent(btnDownload, [statusId]);
          };
        });
      }
    },
    addButtonToMedia: function(listitems) {
      listitems.forEach((li) => {
        if (li.dataset.detected) {
          return;
        }
        li.dataset.detected = "true";
        const statusElement = li.querySelector('a[href*="/status/"]');
        let statusId = null;
        if (statusElement) {
          statusId = this.extractStatusId(statusElement.href);
        }
        if (!statusId) {
          return;
        }
        const btnDownload = document.createElement("div");
        btnDownload.innerHTML = '<div><div><svg viewBox="0 0 20 20" width="15" height="15">' + this.svg + "</svg></div></div>";
        btnDownload.classList.add("x-master-dl", "tmd-media", "download");
        li.appendChild(btnDownload);
        btnDownload.onclick = () => {
          this.clickDownloadEvent(btnDownload, [statusId]);
        };
      });
    },
    flattenByKey: function(obj, key) {
      const res = [];
      (function traverse(o) {
        if (!o || typeof o !== "object")
          return;
        if (key in o)
          res.push(o);
        Object.values(o).forEach(traverse);
      })(obj);
      return res;
    },
    extractMediaFromResponse: function(responseText) {
      try {
        const json = JSON.parse(responseText);
        const all = Object.values(this.flattenByKey(json, "extended_entities"));
        const result = all.flatMap((item) => {
          var _a;
          const entityId = item.id_str || item.conversation_id_str;
          return (((_a = item.extended_entities) == null ? void 0 : _a.media) || []).filter((m) => ["video", "animated_gif", "photo"].includes(m.type)).map((m) => {
            var _a2, _b, _c, _d, _e;
            const bestVideo = (_b = (_a2 = m.video_info) == null ? void 0 : _a2.variants) == null ? void 0 : _b.filter((v) => v.content_type === "video/mp4").sort((a, b) => b.bitrate - a.bitrate)[0];
            return {
              entityId,
              id: m.id_str,
              thumbnail: (_c = m.media_url_https) == null ? void 0 : _c.split(".jpg")[0],
              video: bestVideo == null ? void 0 : bestVideo.url,
              photo: m.media_url_https,
              text: ((_e = (_d = (item.full_text || "").split("https://t.co")[0]) == null ? void 0 : _d.trim()) == null ? void 0 : _e.slice(0, 50)) || entityId
            };
          });
        });
        return result;
      } catch (e) {
        ext.helper.logger.log("error", "Failed to extract media:", e);
      }
      return [];
    },
    fetchListener: function(regex) {
      const self = this;
      (function interceptFetch() {
        const origFetch = window.fetch;
        window.fetch = function(...args) {
          return __async$1(this, null, function* () {
            var _a;
            try {
              const request = args[0];
              const url = typeof request === "string" ? request : request == null ? void 0 : request.url;
              const isMatch = regex.test(url);
              const response = yield origFetch.apply(this, args);
              if (isMatch && response.ok && ((_a = response.headers.get("content-type")) == null ? void 0 : _a.includes("application/json"))) {
                const cloned = response.clone();
                cloned.text().then((text) => {
                  try {
                    self.processResponseBody(text);
                  } catch (e) {
                  }
                }).catch((err) => {
                });
              }
              return response;
            } catch (e) {
              throw e;
            }
          });
        };
      })();
    },
    requestListener: function(regex) {
      const self = this;
      (function interceptXHR() {
        const origOpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function(method, url) {
          this._interceptedUrl = url;
          if (regex.test(url)) {
            const origSend = this.send;
            this.send = function() {
              if (!this._hasInterceptListener && typeof this.addEventListener === "function") {
                this.addEventListener("readystatechange", function() {
                  try {
                    const isDone = this.readyState === 4;
                    const isSuccess = this.status >= 200 && this.status < 300;
                    const isText = !this.responseType || this.responseType === "text";
                    if (isDone && isSuccess && isText && typeof this.responseText === "string") {
                      self.processResponseBody(this.responseText);
                    }
                  } catch (e) {
                  }
                });
                this._hasInterceptListener = true;
              }
              try {
                origSend.apply(this, arguments);
              } catch (e) {
              }
            };
          }
          try {
            return origOpen.apply(this, arguments);
          } catch (e) {
          }
        };
      })();
    },
    processResponseBody: function(content) {
      const medias = this.extractMediaFromResponse(content);
      if (medias.length) {
        medias.forEach((media) => {
          this.mediaMap[media.entityId] = media;
        });
      }
    },
    init: function() {
      GM_addStyle(css_248z + (this.showSensitive ? css_248z$1 : ""));
      const API_REGEX = /(api\.)?(twitter|x)\.com\/(i\/api\/)?(2|media|graphql|1\.1)\//i;
      this.requestListener(API_REGEX);
      this.fetchListener(API_REGEX);
    }
  };
  const X = {
    XSettingsDialog,
    XDateFormat,
    XDownload
  };

  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  const Tiktok = {
    download: function(playId) {
      if (playId) {
        Tools.openInTab("https://www.tikfork.com/en/tk?s=10&url=https://www.tiktok.com/@/video/" + playId);
      }
    },
    downloadSVG: `<svg t="1751880898865" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5364" width="22" height="22"><path d="M860 64H164c-55.2 0-100 44.8-100 100v696c0 55.2 44.8 100 100 100h696c55.2 0 100-44.8 100-100V164c0-55.2-44.8-100-100-100zM709.5 566.4L536.9 764.3c-13.2 15.1-36.6 15.1-49.8 0L314.5 566.4c-15.5-17.8-2.9-45.5 20.7-45.5h119.7V284.5c0-19.9 16.1-36.1 36.1-36.1h42c19.9 0 36.1 16.1 36.1 36.1v236.4h119.7c23.6-0.1 36.2 27.7 20.7 45.5z" fill="#FFFFFF" p-id="5365"></path></svg>`,
    findAncestorByClass: function(element, className, maxDepth = Infinity) {
      let current = element;
      let depth = 0;
      while (current && depth < maxDepth) {
        current = current.parentElement;
        depth++;
        if (current && current.classList.contains(className)) {
          return current;
        }
      }
      return null;
    },
    extractLastDashNumber: function(str) {
      if (!str)
        return null;
      const match = str.match(/-(\d+)$/);
      return match ? match[1] : null;
    },
    start: function() {
      return __async(this, null, function* () {
        if (!/www\.tiktok\.com/.test(window.location.host)) {
          return;
        }
        const randomId = Math.floor(1e5 + Math.random() * 9e5);
        GM_addStyle(`
      .sc-download-` + randomId + `{
        cursor:pointer;
        justify-content:center;
        align-items:center;
        width:48px;
        height:48px;
        z-index:99999;position:absolute;right:55px;top:0px;border-radius:50%;
        display: flex;
      }
    `);
        setInterval(() => {
          document.querySelectorAll("video").forEach((element, index) => {
            const parentNode = element.parentNode;
            if (!parentNode.querySelector("*[x-add='true']")) {
              const downloadElement = document.createElement("div");
              downloadElement.setAttribute("x-add", "true");
              downloadElement.classList.add("sc-download-" + randomId);
              downloadElement.innerHTML = this.downloadSVG;
              parentNode.appendChild(downloadElement);
              downloadElement.addEventListener("click", () => {
                const container = this.findAncestorByClass(parentNode, "xgplayer-container", 3);
                if (container && container.getAttribute("id")) {
                  const playId = this.extractLastDashNumber(container.getAttribute("id"));
                  if (playId)
                    this.download(playId);
                }
              });
            }
          });
        }, 1e3);
      });
    }
  };

  const AllModules = {
    X,
    Tiktok
  };

  const Init = {
    x: function() {
      AllModules.X.XDownload.init();
      AllModules.X.XSettingsDialog.init();
      const observer = new MutationObserver((ms) => ms.forEach((m) => {
        m.addedNodes.forEach((node) => {
          AllModules.X.XDownload.detect(node);
          AllModules.X.XDateFormat.repldatetime();
        });
      }));
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
    },
    tiktok: function() {
      AllModules.Tiktok.start();
    },
    unknown: function() {
    },
    start: function() {
      const otherPlatform = Tools.getOtherPlatform();
      if (otherPlatform) {
        try {
          this[otherPlatform]();
        } catch (e) {
        }
      }
    }
  };
  Init.start();

}());
